= CHINGU
SOURCE: http://github.com/ippa/chingu/tree/master
DOCUMENTATION: http://rdoc.info/projects/ippa/chingu

This is a early preview, alot of functionality is still missing!

== DESCRIPTION
Game framework built on top of the opengl accelerated gamelib Gosu. "Chingu" means "Friend" in korean.

== THE STORY
The last years I've dabbled around alot with gamedevelopment.
I've developed games in both Rubygame and Gosu. I've looked at gamebox.
Rubygame is a very capable framework with alot of functionallity (collision detection, very good eventsystem etc). Gosu is way more minimalistic but also faster with OpenGL-acceleration. Gosu isn't likely to get much more complex since it does what it should do very well and fast.

After 10+ gameprototypes and some finished smaller games I started to see patterns each time I started a new game. Making classes with x/y/image/other-parameters that I called updat/draw on in the mainloop. This became the basic Chingu::GameObject which encapsulates Gosus "Image.draw_rot" and enables automatic updating/drawing.

There was always a huge big chunk of checking keyboard-events in the mainloop.
Borrowing from ideas in rubygame this has now become @player.keyboard(:left => :move_left, :space => :fire ... etc.

With Gosu the mainwindow inherits from Gosu::Window. In Chingu we use Chingu::Window. It's a basic Gosu::Window with extra cheese on top of it. keyboardhandling, automatic update/draw calls to all gameobjects, fps counting etc.

By no means do I claim Chingu to be a "complete stack" for gamedev. Rather it's a set of extensions to the minimalistic but fast Gosu to make you do more with less code.

While others has gone for very flexible systems with premade includable gamelogic and "behaivor"-modules Chingus core is pretty simple and minimalistic.

== THE BASICS

=== Chingu::Window

You're probably familiar with this very common Gosu pattern:
  
  ROOT_PATH = File.dirname(File.expand_path(__FILE__))
  class Game < Gosu::Window
    def initialize
      @player = Player.new
    end
    
    def update
      if button_down? Button::KbLeft
        @player.left
      elsif button_down? Button::KbRight
        @player.right
      end
      
      @player.update      
    end
    
    def draw
      @player.draw
    end
  end
  
  class Player
    attr_accessor :x,:y,:image
    def initialize(options)
      @x = options[:x]
      @y = options[:y]
      @image = Image.new(File.join(ROOT_PATH, "media", "player.png"))
    end
    
    def move_left
      @x -= 1
    end
    
    def move_right
      @x += 1
    end
    
    def draw
      @image.draw(@x,@y,100)
    end
  end
  
  Game.new.show   # Start the Game update/draw loop!


Chingu doesn't change any fundamental concept of Gosu, but it will make the above code cleaner:
  
  #
  # We use Chingu::Window instead of Gosu::Window
  #
  class Game < Chingu:Window
    def initialize
      super # This is always needed
      #
      # Player will automaticly be updated and drawn since it's a Chingu::GameObject
      # You'll need your own Game#update/#draw after a while, but just put #super there and Chingu can do its thing!
      #
      @player = Player.new
      @player.keymap = {:left => :move_left, :right => :move_right}
    end    
  end
    
  #
  # If we create classes from Chingu::GameObject we get stuff for free.
  # The accessors: image,x,y,zorder,angle,factor_x,factor_y,center_x,center_y,mode,update,draw
  # You might regognize thoose from #draw_rot - http://www.libgosu.org/rdoc/classes/Gosu/Image.html#M000023
  # And in it's core, that's what Chingu::GameObject is, an encapsulation of draw_rot with some extra cheese.
  # For eaxmple, we get automatic calls to draw/update with Chingu::GameObject, which usually is what you want. 
  # You could stop this by doing: @player = Player.new(:draw => false, :update => false)
  #
  class Player < Chingu::GameObject
    def initialize(options)
      super(options.merge(:image => Image["player.png"])
    end
    
    def move_left
      @x -= 1
    end
    
    def move_right
      @x += 1
    end    
  end

  Game.new.show   # Start the Game update/draw loop!
  
Roughly 50 lines became 26 more powerful lines. (you can do @player.angle = 100 for example)

If you've worked with Gosu for a while you're probably tired of passing around the window-parameter.
Chingu solves this (as has many other developers) with a global variable $window. Yes, globals are bad, but in this case it kinda makes sense. It's used under the hood in various places.

=== Chingu::GameObject
This is our basic "gameunit"-class, meaning most ingame objects (players, enemies, bullets etc) should be inherited from Chingu::GameObject. The basic ideas behind it are:

* Encapsulate only the very common basics that Most ingame objects need
* Keep naming close to Gosu, but add smart convenientmethods / shortcuts and a more rubyish feeling
* No gamelogic at all allowed in GameObject, since that is most likely usefull for others

I've chose to base it around Image#draw_rot. So basicly all the arguments that you pass to draw_rot can be passed to GameObject#new when creating a new object, an example using almost all arguments would be:
  
  #
  # You probably recognize the arguments from http://www.libgosu.org/rdoc/classes/Gosu/Image.html#M000023
  #
  @player = Player.new(:image => Image["player.png"], :x=>100, :y=>100, :zorder=>100, :angle=>45, :factor_x=>10, :factor_y=>10, :center_x=>0, :center_y=>0)
  
  #
  # A shortcut for the above line would be
  #
  @player = Player.new(:image => Image["player.png"], :x=>100, :y=>100, :zorder=>100, :angle=>45, :factor=>10, :center=>0)

  #
  # I've tried doing sensible defaults:
  # x/y = [middle of the screen]  for superquick display where it should be easy in sight)
  # angle = 0                     (no angle by default)
  # center_x/center_y = 0.5       (basicly the center of the image will be drawn at x/y)
  # factor_x/factor_y = 1         (no zoom by default)
  # 
  @player = Player.new
  
  #
  # By default Chingu::Window calls update & draw on all GameObjects in it's own update/draw.
  # If this is not what you want, use :draw and :update
  #
  @player = Player.new(:draw => false, :update => false)

=== GameState / GameStateManager
Chingu incorperates a basic push/pop gamestate system (as discuessed here: http://www.gamedev.net/community/forums/topic.asp?topic_id=477320).

Gamestates is a way of organizing your intros, menus, levels.

Gamestates aren't complicated. In Chingu a GameState is a class that behaves mostly like your default Gosu::Window (or in our case Chingu::Window) gameloop.

  
  class Intro < Chingu::GameState
    def update
      # gamelogic here
    end
    
    def draw
      # screen manipulation here
    end
    
    def button_down(id)
      # called when a button is pressed
    end
    
    def finalize
      push_gamestate(Menu.new)  # Called when Intro dies for whatever reason.
    end
    
    # etc etc
  end

Looks familiar ye?
Active that gamestate/gameloop in your mainwindow (which is always the spider in the net).

  class Game < Chingu::Window
    def initialize
      push_gamestate(Intro.new)
    end
  end
  
A GameState in Chingu is just a class with the following instancemethods: 

* setup()     - called when gamestate becomes active (switch_gamestate(gamestate) for example)
* button_down(id) - Called when a button is down
* button_up(id)   - Called when a button is released
* update()    - just as in your normal gameloop, put your gamelogic here.
* draw()      - just as in your normal gameloop, pur your draws here.
* finalize()  - called when a gamestate is finished

Chingu::Window automaticly creates a @game_state_manager and makes it accessible in our gameloop.
By default the gameloop calls update() / draw() on the the current gamestate.

Chingu also has a couple of helpers to easy change between gamestates.
In a mainloop or in a gamestate:
* push_gamestate(state)     - adds a new gamestate, which then becomes the active one
* pop_gamestate             - removes active gamestate and activates the previous one
* switch_gamestate(state)   - pop all gamestates until given state is found

To switch to a certain gamestate with a keypress use Chingus keymapper:
  class Intro < Chingu::GameState
    def setup
      self.keymap = { :space => lambda{push_gamestate(Menu.new)} }
    end
  end
  
Or Chingus pretty shortcut:

  class Intro < Chingu::GameState
    def setup
      self.keymap = { :space => Menu }      #  { :space => Menu.new } works as well.
    end
  end

Chingu will detect that Menu is a gamestate-class and call push_gamestate on it when space is pressed inside Intro.

=== Assets / Paths

You might wonder why this is nessesary in the straight Gosu example:
  ROOT_PATH = File.dirname(File.expand_path(__FILE__))
  @image = Image.new(File.join(ROOT_PATH, "media", "player.png"))

It enables you to start your game from any directory and it will still find your assets (pictures, samples, fonts etc..) correctly.
For a local developmentversion this might not be important, you're likely to start the game from the games root-dir.
But as soon as you try to deploy (for example to windows with Ocra - http://github.com/larsch/ocra/tree/master) you'll run into trouble of you dont do it like that.
 
Chingu solves this problem behind the scenes for the most common assets. The 2 lines above can be replaced with:
Image["player.png"]

You also have Sound["player.png"]

Tiles and fonts are trickier since they require extra parameters so you'll have to do thoose the ordinary way.
You'll get $window.root (equivalent to ROOT_PATH above) for free though which points to the dir containing the game.


== TODO:
* Complete the keymap-definitions with all possible keys
* Complete keymap-stuff with released-states etc
* More gfx effects, for example: fade in/out to a specific color (black makes sense between levels).
* Summon good proven community gosu snippets into Chingu
* -Generate docs @ ippa.github.com-  http://rdoc.info/projects/ippa/chingu !
* -A good scene-manager to manage welcomescreens, levels and gameflow- GameStateManager / GameState !
* More docs
* -Make a gem- first gem made on github
* Automate gemgenning rake-task even more
* More examples when effects are more complete
* class ChipmunkObject
* class Actor/MovingActor with maybe abit more logic then the basic GameObject. Would ppl find is useful?
* Spellcheck all docs, sloppy spelling turns ppl off.
* Tests
* Streamline fps / tick code
* Encapsulate Font.new / draw_rot with a "class Text < GameObject"
* Make it possible for ppl to use the parts of chingu they like
* A more robust gamestate <-> game_object system to connect them together.

== WHY?
* Plain gosu is very minimalistic, perfect to build some higherlevel logic on!
* Deployment and assethandling should be simple
* Managing gamestates/scenes (intros, menus, levels etc) should be simple
* There are patterns in gamedevelopment

== OPINIONS
* Less code is usually better
* Hasharguments FTW. And it becomes even better in 1.9.
* Don't separate too much from Gosus core-naming

== CREDITS:
Jacius of Rubygame (For doing cool stuff that's well documented as re-usable). So far rect.rb and named_resource.rb is taken from Rubygame.

jlnr,philymore,shawn24 for contructive feedback



== REQUIREMENTS:
* Gosu latest version
* Ruby 1.8/1.9